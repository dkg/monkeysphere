# -*-shell-script-*-

# Shared sh functions for the monkeysphere
#
# Written by
# Jameson Rollins <jrollins@fifthhorseman.net>
#
# Copyright 2008, released under the GPL, version 3 or later

# all-caps variables are meant to be user supplied (ie. from config
# file) and are considered global

########################################################################
### COMMON VARIABLES

# managed directories
ETC="/etc/monkeysphere"
export ETC
CACHE="/var/cache/monkeysphere"
export CACHE

########################################################################
### UTILITY FUNCTIONS

error() {
    log "$1"
    ERR=${2:-'1'}
}

failure() {
    echo "$1" >&2
    exit ${2:-'1'}
}

# write output to stderr
log() {
    echo -n "ms: " >&2
    echo "$@" >&2
}

loge() {
    echo "$@" >&2
}

# cut out all comments(#) and blank lines from standard input
meat() {
    grep -v -e "^[[:space:]]*#" -e '^$'
}

# cut a specified line from standard input
cutline() {
    head --line="$1" | tail -1
}

# check that characters are in a string (in an AND fashion).
# used for checking key capability
# check_capability capability a [b...]
check_capability() {
    local usage
    local capcheck

    usage="$1"
    shift 1

    for capcheck ; do
	if echo "$usage" | grep -q -v "$capcheck" ; then
	    return 1
	fi
    done
    return 0
}

# convert escaped characters from gpg output back into original
# character
# FIXME: undo all escape character translation in with-colons gpg output
unescape() {
    echo "$1" | sed 's/\\x3a/:/'
}

# remove all lines with specified string from specified file
remove_line() {
    local file
    local string

    file="$1"
    string="$2"

    if [ "$file" -a "$string" ] ; then
	grep -v "$string" "$file" | sponge "$file"
    fi
}

# translate ssh-style path variables %h and %u
translate_ssh_variables() {
    local uname
    local home

    uname="$1"
    path="$2"

    # get the user's home directory
    userHome=$(getent passwd "$uname" | cut -d: -f6)

    # translate '%u' to user name
    path=${path/\%u/"$uname"}
    # translate '%h' to user home directory
    path=${path/\%h/"$userHome"}

    echo "$path"
}

### CONVERTION UTILITIES

# output the ssh key for a given key ID
gpg2ssh() {
    local keyID
    
    #keyID="$1" #TMP
    # only use last 16 characters until openpgp2ssh can take all 40 #TMP
    keyID=$(echo "$1" | cut -c 25-) #TMP

    gpg --export "$keyID" | openpgp2ssh "$keyID" 2> /dev/null
}

# output the ssh key for a given secret key ID
gpgsecret2ssh() {
    local keyID

    #keyID="$1" #TMP
    # only use last 16 characters until openpgp2ssh can take all 40 #TMP
    keyID=$(echo "$1" | cut -c 25-) #TMP

    gpg --export-secret-key "$keyID" | openpgp2ssh "$keyID" 2> /dev/null
}

# output known_hosts line from ssh key
ssh2known_hosts() {
    local host
    local key

    host="$1"
    key="$2"

    echo -n "$host "
    echo -n "$key" | tr -d '\n'
    echo " MonkeySphere${DATE}"
}

# output authorized_keys line from ssh key
ssh2authorized_keys() {
    local userID
    local key
    
    userID="$1"
    key="$2"

    echo -n "$key" | tr -d '\n'
    echo " MonkeySphere${DATE} ${userID}"
}

# convert key from gpg to ssh known_hosts format
gpg2known_hosts() {
    local host
    local keyID

    host="$1"
    keyID="$2"

    # NOTE: it seems that ssh-keygen -R removes all comment fields from
    # all lines in the known_hosts file.  why?
    # NOTE: just in case, the COMMENT can be matched with the
    # following regexp:
    # '^MonkeySphere[[:digit:]]{4}(-[[:digit:]]{2}){2}T[[:digit:]]{2}(:[[:digit:]]{2}){2}$'
    echo -n "$host "
    gpg2ssh "$keyID" | tr -d '\n'
    echo " MonkeySphere${DATE}"
}

# convert key from gpg to ssh authorized_keys format
gpg2authorized_keys() {
    local userID
    local keyID

    userID="$1"
    keyID="$2"

    # NOTE: just in case, the COMMENT can be matched with the
    # following regexp:
    # '^MonkeySphere[[:digit:]]{4}(-[[:digit:]]{2}){2}T[[:digit:]]{2}(:[[:digit:]]{2}){2}$'
    gpg2ssh "$keyID" | tr -d '\n'
    echo " MonkeySphere${DATE} ${userID}"
}

### GPG UTILITIES

# retrieve all keys with given user id from keyserver
# FIXME: need to figure out how to retrieve all matching keys
# (not just first N (5 in this case))
gpg_fetch_userid() {
    local userID

    userID="$1"

    log -n " checking keyserver $KEYSERVER... "
    echo 1,2,3,4,5 | \
	gpg --quiet --batch --with-colons \
	--command-fd 0 --keyserver "$KEYSERVER" \
	--search ="$userID" > /dev/null 2>&1
    loge "done."
}

# get the full fingerprint of a key ID
get_key_fingerprint() {
    local keyID

    keyID="$1"

    gpg --list-key --with-colons --fixed-list-mode \
	--with-fingerprint --with-fingerprint "$keyID" | \
	grep '^fpr:' | grep "$keyID" | cut -d: -f10
}

########################################################################
### PROCESSING FUNCTIONS

# userid and key policy checking
# the following checks policy on the returned keys
# - checks that full key has appropriate valididy (u|f)
# - checks key has specified capability (REQUIRED_*_KEY_CAPABILITY)
# - checks that requested user ID has appropriate validity
# (see /usr/share/doc/gnupg/DETAILS.gz)
# output is one line for every found key, in the following format:
#
# flag fingerprint
#
# "flag" is an acceptability flag, 0 = ok, 1 = bad
# "fingerprint" is the fingerprint of the key
#
# expects global variable: "MODE"
process_user_id() {
    local userID
    local requiredCapability
    local requiredPubCapability
    local gpgOut
    local type
    local validity
    local keyid
    local uidfpr
    local usage
    local keyOK
    local uidOK
    local lastKey
    local lastKeyOK
    local fingerprint

    userID="$1"

    # set the required key capability based on the mode
    if [ "$MODE" = 'known_hosts' ] ; then
	requiredCapability="$REQUIRED_HOST_KEY_CAPABILITY"
    elif [ "$MODE" = 'authorized_keys' ] ; then
	requiredCapability="$REQUIRED_USER_KEY_CAPABILITY"	
    fi
    requiredPubCapability=$(echo "$requiredCapability" | tr "[:lower:]" "[:upper:]")

    # if CHECK_KEYSERVER variable set, check the keyserver
    # for the user ID
    if [ "$CHECK_KEYSERVER" = "true" ] ; then
	gpg_fetch_userid "$userID"
    fi

    # output gpg info for (exact) userid and store
    gpgOut=$(gpg --list-key --fixed-list-mode --with-colon \
	--with-fingerprint --with-fingerprint \
	="$userID" 2>/dev/null)

    # if the gpg query return code is not 0, return 1
    if [ "$?" -ne 0 ] ; then
        log "  - key not found."
        return 1
    fi

    # loop over all lines in the gpg output and process.
    # need to do it this way (as opposed to "while read...") so that
    # variables set in loop will be visible outside of loop
    echo "$gpgOut" | cut -d: -f1,2,5,10,12 | \
    while IFS=: read -r type validity keyid uidfpr usage ; do
	# process based on record type
	case $type in
	    'pub') # primary keys
		# new key, wipe the slate
		keyOK=
		uidOK=
		lastKey=pub
		lastKeyOK=
		fingerprint=

		log " primary key found: $keyid"

		# if overall key is not valid, skip
		if [ "$validity" != 'u' -a "$validity" != 'f' ] ; then
		    log "  - unacceptable primary key validity ($validity)."
		    continue
		fi
		# if overall key is disabled, skip
		if check_capability "$usage" 'D' ; then
		    log "  - key disabled."
		    continue
		fi
		# if overall key capability is not ok, skip
		if ! check_capability "$usage" $requiredPubCapability ; then
		    log "  - unacceptable primary key capability ($usage)."
		    continue
		fi

		# mark overall key as ok
		keyOK=true

		# mark primary key as ok if capability is ok
		if check_capability "$usage" $requiredCapability ; then
		    lastKeyOK=true
		fi
		;;
	    'uid') # user ids
		# if an acceptable user ID was already found, skip
		if [ "$uidOK" ] ; then
		    continue
		fi
		# if the user ID does not match, skip
		if [ "$(unescape "$uidfpr")" != "$userID" ] ; then
		    continue
		fi
		# if the user ID validity is not ok, skip
		if [ "$validity" != 'u' -a "$validity" != 'f' ] ; then
		    continue
		fi

		# mark user ID acceptable
		uidOK=true

		# output a line for the primary key
		# 0 = ok, 1 = bad
		if [ "$keyOK" -a "$uidOK" -a "$lastKeyOK" ] ; then
		    log "  * acceptable key found."
		    echo "0:${fingerprint}"
		else
		    echo "1:${fingerprint}"
		fi
		;;
	    'sub') # sub keys
		# unset acceptability of last key
		lastKey=sub
		lastKeyOK=
		fingerprint=

		# if sub key validity is not ok, skip
		if [ "$validity" != 'u' -a "$validity" != 'f' ] ; then
		    continue
		fi
		# if sub key capability is not ok, skip
		if ! check_capability "$usage" $requiredCapability ; then
		    continue
		fi

		# mark sub key as ok
		lastKeyOK=true
		;;
	    'fpr') # key fingerprint
		fingerprint="$uidfpr"

		# if the last key was the pub key, skip
		if [ "$lastKey" = pub ] ; then
		    continue
		fi
		
		# output a line for the last subkey
		# 0 = ok, 1 = bad
		if [ "$keyOK" -a "$uidOK" -a "$lastKeyOK" ] ; then
		    log "  * acceptable key found."
		    echo "0:${fingerprint}"
		else
		    echo "1:${fingerprint}"
		fi
		;;
	esac
    done
}

# process a single host in the known_host file
process_host_known_hosts() {
    local host
    local userID
    local ok
    local keyid
    local tmpfile
    local returnCode

    # default return code is 1, which assumes no key was found
    returnCode=1

    host="$1"

    log "processing host: $host"

    userID="ssh://${host}"

    for line in $(process_user_id "ssh://${host}") ; do
	ok=$(echo "$line" | cut -d: -f1)
	keyid=$(echo "$line" | cut -d: -f2)

	sshKey=$(gpg2ssh "$keyid")
	# remove the old host key line
	remove_line "$KNOWN_HOSTS" "$sshKey"
	# if key OK, add new host line
	if [ "$ok" -eq '0' ] ; then
	    # hash if specified
	    if [ "$HASH_KNOWN_HOSTS" = 'true' ] ; then
		# FIXME: this is really hackish cause ssh-keygen won't
		# hash from stdin to stdout
		tmpfile=$(mktemp)
		ssh2known_hosts "$host" "$sshKey" > "$tmpfile"
		ssh-keygen -H -f "$tmpfile" 2> /dev/null
		cat "$tmpfile" >> "$KNOWN_HOSTS"
		rm -f "$tmpfile" "${tmpfile}.old"
	    else
		ssh2known_hosts "$host" "$sshKey" >> "$KNOWN_HOSTS"
	    fi
	    # set return code to be 0, since a key was found
	    returnCode=0
	fi
	return "$returnCode"
    done

    return "$returnCode"
}

# update the known_hosts file for a set of hosts listed on command
# line
update_known_hosts() {
    local host
    local returnCode

    # default return code is 0, which assumes a key was found for
    # every host.  code will be set to 1 if a key is not found for at
    # least one host
    returnCode=0

    # set the trap to remove any lockfiles on exit
    trap "lockfile-remove $KNOWN_HOSTS" EXIT

    # create a lockfile on known_hosts
    lockfile-create "$KNOWN_HOSTS"

    for host ; do
	# process the host, change return code if host key not found
	process_host_known_hosts "$host" || returnCode=1
	
	# touch the lockfile, for good measure.
	lockfile-touch --oneshot "$KNOWN_HOSTS"
    done

    # remove the lockfile
    lockfile-remove "$KNOWN_HOSTS"

    return "$returnCode"
}

# process known_hosts file, going through line-by-line, extract each
# host, and process with the host processing function
process_known_hosts() {
    local returnCode

    # default return code is 0, which assumes a key was found for
    # every host.  code will be set to 1 if a key is not found for at
    # least one host
    returnCode=0

    # take all the hosts from the known_hosts file (first field), grep
    # out all the hashed hosts (lines starting with '|')...
    for line in $(cat "$KNOWN_HOSTS" | meat | cut -d ' ' -f 1 | grep -v '^|.*$') ; do
	# break up hosts into separate words
	update_known_hosts $(echo "$line" | tr , ' ') || returnCode=1
    done

    return "$returnCode"
}

# process uids for the authorized_keys file
process_uid_authorized_keys() {
    local userID
    local ok
    local keyid
    local returnCode

    # default return code is 1, which assumes no key was found
    returnCode=1

    userID="$1"

    log "processing user ID: $userID"

    for line in $(process_user_id "$userID") ; do
	ok=$(echo "$line" | cut -d: -f1)
	keyid=$(echo "$line" | cut -d: -f2)

	sshKey=$(gpg2ssh "$keyid")
	# remove the old host key line
	remove_line "$AUTHORIZED_KEYS" "$sshKey"
	# if key OK, add new host line
	if [ "$ok" -eq '0' ] ; then
	    ssh2authorized_keys "$userID" "$sshKey" >> "$AUTHORIZED_KEYS"

	    # set return code to be 0, since a key was found
	    returnCode=0
	fi
    done

    return "$returnCode"
}

# update the authorized_keys files from a list of user IDs on command
# line
update_authorized_keys() {
    local userID
    local returnCode

    # default return code is 0, which assumes a key was found for
    # every user ID.  code will be set to 1 if a key is not found for
    # at least one user ID
    returnCode=0

    # set the trap to remove any lockfiles on exit
    trap "lockfile-remove $AUTHORIZED_KEYS" EXIT

    # create a lockfile on authorized_keys
    lockfile-create "$AUTHORIZED_KEYS"

    for userID ; do
	# process the user ID, change return code if key not found for
	# user ID
	process_uid_authorized_keys "$userID" || returnCode=1

	# touch the lockfile, for good measure.
	lockfile-touch --oneshot "$AUTHORIZED_KEYS"
    done

    # remove the lockfile
    lockfile-remove "$AUTHORIZED_KEYS"

    return "$returnCode"
}

# process an authorized_user_ids file for authorized_keys
process_authorized_user_ids() {
    local userid
    local returnCode

    # default return code is 0, and is set to 1 if a key for a user ID
    # is not found
    returnCode=0

    authorizedUserIDs="$1"

    # set the IFS to be newline for parsing the authorized_user_ids
    # file.  can't find it in BASH(1) (found it on the net), but it
    # works.
    IFS=$'\n'
    for userid in $(cat "$authorizedUserIDs" | meat) ; do
	update_authorized_keys "$userid" || returnCode=1
    done

    return "$returnCode"
}

# EXPERIMENTAL (unused) process userids found in authorized_keys file
# go through line-by-line, extract monkeysphere userids from comment
# fields, and process each userid
# NOT WORKING
process_authorized_keys() {
    local authorizedKeys
    local userID
    local returnCode

    # default return code is 0, and is set to 1 if a key for a user
    # is not found
    returnCode=0

    authorizedKeys="$1"

    # take all the monkeysphere userids from the authorized_keys file
    # comment field (third field) that starts with "MonkeySphere uid:"
    # FIXME: needs to handle authorized_keys options (field 0)
    cat "$authorizedKeys" | meat | \
    while read -r options keytype key comment ; do
	# if the comment field is empty, assume the third field was
	# the comment
	if [ -z "$comment" ] ; then
	    comment="$key"
	fi

	if echo "$comment" | egrep -v -q '^MonkeySphere[[:digit:]]{4}(-[[:digit:]]{2}){2}T[[:digit:]]{2}(:[[:digit:]]{2}){2}' ; then
	    continue
	fi
	userID=$(echo "$comment" | awk "{ print $2 }")
	if [ -z "$userID" ] ; then
	    continue
	fi

	# process the userid
	log "processing userid: '$userID'"
	process_user_id "$userID" > /dev/null || returnCode=1
    done

    return "$returnCode"
}

##################################################
### GPG HELPER FUNCTIONS

# retrieve key from web of trust, and set owner trust to "full"
# if key is found.
trust_key() {
    local keyID
    local trustLevel

    keyID="$1"
    trustLevel="$2"

    if [ -z "$keyID" ] ; then
	failure "You must specify key to trust."
    fi

    # get the key from the key server
    if ! gpg --keyserver "$KEYSERVER" --recv-key "$keyID" ; then
	failure "Could not retrieve key '$keyID'."
    fi

    # get key fingerprint
    fingerprint=$(get_key_fingerprint "$keyID")

    echo "key found:"
    gpg --fingerprint "$fingerprint"

    while [ -z "$trustLevel" ] ; do
	cat <<EOF
Please decide how far you trust this user to correctly verify other users' keys
(by looking at passports, checking fingerprints from different sources, etc.)

  1 = I don't know or won't say
  2 = I do NOT trust
  3 = I trust marginally
  4 = I trust fully
  5 = I trust ultimately

EOF
	read -p "Your decision? " trustLevel
	if echo "$trustLevel" | grep -v "[1-5]" ; then
	    echo "Unknown trust level '$trustLevel'."
	    unset trustLevel
	elif [ "$trustLevel" = 'q' ] ; then
	    failure "Aborting."
	fi
    done

    # attach a "non-exportable" signature to the key
    # this is required for the key to have any validity at all
    # the 'y's on stdin indicates "yes, i really want to sign"
    echo -e 'y\ny' | gpg --quiet --lsign-key --command-fd 0 "$fingerprint"

    # index trustLevel by one to difference between level in ui and level
    # internally
    trustLevel=$((trustLevel+1))

    # import new owner trust level for key
    echo "${fingerprint}:${trustLevel}:" | gpg --import-ownertrust
    if [ $? = 0 ] ; then
	log "Owner trust updated."
    else
	failure "There was a problem changing owner trust."
    fi	
}

# publish server key to keyserver
publish_server_key() {
    read -p "really publish key to $KEYSERVER? [y|N]: " OK; OK=${OK:=N}
    if [ ${OK/y/Y} != 'Y' ] ; then
	failure "aborting."
    fi

    # publish host key
    # FIXME: need to figure out better way to identify host key
    # dummy command so as not to publish fakes keys during testing
    # eventually:
    #gpg --keyserver "$KEYSERVER" --send-keys $(hostname -f)
    failure "NOT PUBLISHED (to avoid permanent publication errors during monkeysphere development).
To publish manually, do: gpg --keyserver $KEYSERVER --send-keys $(hostname -f)"
}
