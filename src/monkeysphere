#!/bin/bash

# monkeysphere: MonkeySphere client tool
#
# The monkeysphere scripts are written by:
# Jameson Rollins <jrollins@fifthhorseman.net>
#
# They are Copyright 2008, and are all released under the GPL, version 3
# or later.

########################################################################
PGRM=$(basename $0)

SHAREDIR=${SHAREDIR:-"/usr/share/monkeysphere"}
export SHAREDIR
. "${SHAREDIR}/common"

GLOBAL_CONFIG=${GLOBAL_CONFIG:-"${ETC}/monkeysphere.conf"}
[ -r "$GLOBAL_CONFIG" ] && . "$GLOBAL_CONFIG"

# date in UTF format if needed
DATE=$(date -u '+%FT%T')

# unset some environment variables that could screw things up
GREP_OPTIONS=

########################################################################
# FUNCTIONS
########################################################################

usage() {
cat <<EOF
usage: $PGRM <subcommand> [args]
MonkeySphere client tool.

subcommands:
  update-known_hosts (k) [HOST]...  update known_hosts file
  update-userids (u) [USERID]...    add/update user IDs
  remove-userids (r) [USERID]...    remove user IDs
  update-authorized_keys (a)        update authorized_keys file
  gen-subkey (g) KEYID              generate an 'a' capable subkey
  help (h,?)                        this help

EOF
}

# generate a subkey with the 'a' usage flags set
# FIXME: not working yet.
gen_subkey(){
    local keyID
    local gpgOut
    local userID

    log "warning: this function is still not working."

    keyID="$1"

    gpgOut=$(gpg --fixed-list-mode --list-keys --with-colons \
	"$keyID" 2> /dev/null)

    # return 1 if there only "tru" lines are output from gpg
    if [ -z "$(echo "$gpgOut" | grep -v '^tru:')" ] ; then
	log "  key not found."
	return 1
    fi

    # set subkey defaults
    SUBKEY_TYPE=${SUBKEY_TYPE:-"RSA"}
    #SUBKEY_LENGTH=${SUBKEY_LENGTH:-"2048"}
    SUBKEY_USAGE=${SUBKEY_USAGE:-"auth"}
    SUBKEY_EXPIRE=${SUBKEY_EXPIRE:-"0"}
    cat <<EOF
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
EOF
    read -p "Key is valid for? ($SUBKEY_EXPIRE) " SUBKEY_EXPIRE; SUBKEY_EXPIRE=${SUBKEY_EXPIRE:-"0"}

    # generate the list of commands that will be passed to edit-key
    editCommands=$(cat <<EOF
addkey
7
S
E
A
Q
$SUBKEY_LENGTH
$SUBKEY_EXPIRE
save
EOF
)

    echo "generating subkey..."
    echo "$editCommands" | gpg --expert --command-fd 0 --edit-key "$keyID"
}

########################################################################
# MAIN
########################################################################

COMMAND="$1"
[ "$COMMAND" ] || failure "Type '$PGRM help' for usage."
shift

# set ms home directory
MS_HOME=${MS_HOME:-"${HOME}/.config/monkeysphere"}

# load configuration file
MS_CONF=${MS_CONF:-"${MS_HOME}/monkeysphere.conf"}
[ -e "$MS_CONF" ] && . "$MS_CONF"

# set empty config variable with defaults
AUTHORIZED_USER_IDS=${AUTHORIZED_USER_IDS:-"${MS_HOME}/authorized_user_ids"}
GNUPGHOME=${GNUPGHOME:-"${HOME}/.gnupg"}
KEYSERVER=${KEYSERVER:-"subkeys.pgp.net"}
REQUIRED_HOST_KEY_CAPABILITY=${REQUIRED_HOST_KEY_CAPABILITY:-"e a"}
REQUIRED_USER_KEY_CAPABILITY=${REQUIRED_USER_KEY_CAPABILITY:-"a"}
USER_CONTROLLED_AUTHORIZED_KEYS=${USER_CONTROLLED_AUTHORIZED_KEYS:-"%h/.ssh/authorized_keys"}
USER_KNOWN_HOSTS=${USER_KNOWN_HOSTS:-"${HOME}/.ssh/known_hosts"}
HASH_KNOWN_HOSTS=${HASH_KNOWN_HOSTS:-"true"}

export GNUPGHOME

# stagging locations
hostKeysCacheDir="${MS_HOME}/host_keys"
userKeysCacheDir="${MS_HOME}/user_keys"
msAuthorizedKeys="${MS_HOME}/authorized_keys"

# make sure gpg home exists with proper permissions
mkdir -p -m 0700 "$GNUPGHOME"

# make sure the user monkeysphere home directory exists
mkdir -p -m 0700 "$MS_HOME"
mkdir -p "$hostKeysCacheDir"
mkdir -p "$userKeysCacheDir"
touch "$AUTHORIZED_USER_IDS"

case $COMMAND in
    'update-known_hosts'|'update-known-hosts'|'k')
	MODE='known_hosts'

        # touch the known_hosts file to make sure it exists
	# ssh-keygen complains if it doesn't exist
	touch "$USER_KNOWN_HOSTS"

        # if hosts are specified on the command line, process just
        # those hosts
	if [ "$1" ] ; then
            for host ; do
		process_host "$host" "$hostKeysCacheDir"
	    done

        # otherwise, if no hosts are specified, process every user
        # in the user's known_hosts file
	else
	    if [ ! -s "$USER_KNOWN_HOSTS" ] ; then
		failure "known_hosts file '$USER_KNOWN_HOSTS' is empty."
	    fi
	    log "processing known_hosts file..."
	    process_known_hosts "$USER_KNOWN_HOSTS" "$hostKeysCacheDir"
	fi
	;;

    'update-userids'|'update-userid'|'u')
	if [ -z "$1" ] ; then
	    failure "you must specify at least one userid."
	fi
	for userID ; do
	    update_userid "$userID" "$userKeysCacheDir"
	done
	log "run the following to update your monkeysphere authorized_keys file:"
	log "$PGRM update-authorized_keys"
	;;

    'remove-userids'|'remove-userid'|'r')
	if [ -z "$1" ] ; then
	    failure "you must specify at least one userid."
	fi
	for userID ; do
	    remove_userid "$userID"
	done
	log "run the following to update your monkeysphere authorized_keys file:"
	log "$PGRM update-authorized_keys"
	;;

    'update-authorized_keys'|'update-authorized-keys'|'a')
	MODE='authorized_keys'

        # fail if the authorized_user_ids file is empty
	if [ ! -s "$AUTHORIZED_USER_IDS" ] ; then
	    failure "$AUTHORIZED_USER_IDS is empty."
	fi

	# set user-controlled authorized_keys file path
	userAuthorizedKeys=${USER_CONTROLLED_AUTHORIZED_KEYS/\%h/"$HOME"}

	# update authorized_keys
	update_authorized_keys "$msAuthorizedKeys" "$userAuthorizedKeys" "$userKeysCacheDir"
	;;

    'gen-subkey'|'g')
	keyID="$1"
	if [ -z "$keyID" ] ; then
	    failure "you must specify keyid of primary key."
	fi
	gen_subkey "$keyID"
	;;

    'help'|'h'|'?')
        usage
        ;;

    *)
        failure "Unknown command: '$COMMAND'
Type '$PGRM help' for usage."
        ;;
esac
