#!/bin/bash

# monkeysphere: MonkeySphere client tool
#
# The monkeysphere scripts are written by:
# Jameson Rollins <jrollins@fifthhorseman.net>
#
# They are Copyright 2008, and are all released under the GPL, version 3
# or later.

########################################################################
PGRM=$(basename $0)

SHARE=${MONKEYSPHERE_SHARE:-"/usr/share/monkeysphere"}
export SHARE
. "${SHARE}/common" || exit 1

# date in UTF format if needed
DATE=$(date -u '+%FT%T')

# unset some environment variables that could screw things up
unset GREP_OPTIONS

# default return code
RETURN=0

# set the file creation mask to be only owner rw
umask 077

########################################################################
# FUNCTIONS
########################################################################

usage() {
    cat <<EOF
usage: $PGRM <subcommand> [options] [args]
MonkeySphere client tool.

subcommands:
  update-known_hosts (k) [HOST]...  update known_hosts file
  update-authorized_keys (a)        update authorized_keys file
  gen-subkey (g) KEYID              generate an 'a' capable subkey
    -l|--length BITS                  key length in bits (2048)
    -e|--expire EXPIRE                date to expire
  help (h,?)                        this help

EOF
}

# generate a subkey with the 'a' usage flags set
gen_subkey(){
    local keyLength
    local keyExpire
    local keyID
    local gpgOut
    local userID

    # set default key parameter values
    keyLength=
    keyExpire=

    # get options
    TEMP=$(getopt -o l:e: -l length:,expire: -n "$PGRM" -- "$@")

    if [ $? != 0 ] ; then
	exit 1
    fi

    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$TEMP"

    while true ; do
	case "$1" in
	    -l|--length)
		keyLength="$2"
		shift 2
		;;
	    -e|--expire)
		keyExpire="$2"
		shift 2
		;;
	    --)
		shift
		;;
            *)
		break
		;;
	esac
    done

    if [ -z "$1" ] ; then
	# find all secret keys
	keyID=$(gpg --with-colons --list-secret-keys | grep ^sec | cut -f5 -d:)
	# if multiple sec keys exist, fail
	if (( $(echo "$keyID" | wc -l) > 1 )) ; then
	    echo "Multiple secret keys found:"
	    echo "$keyID"
	    failure "Please specify which primary key to use."
	fi
    else
	keyID="$1"
    fi
    if [ -z "$keyID" ] ; then
	failure "You have no secret key available.  You should create an OpenPGP
key before joining the monkeysphere. You can do this with:
   gpg --gen-key"
    fi

    # get key output, and fail if not found
    gpgOut=$(gpg --quiet --fixed-list-mode --list-secret-keys --with-colons \
	"$keyID") || failure

    # fail if multiple sec lines are returned, which means the id
    # given is not unique
    if [ $(echo "$gpgOut" | grep '^sec:' | wc -l) -gt '1' ] ; then
	failure "Key ID '$keyID' is not unique."
    fi

    # prompt if an authentication subkey already exists
    if echo "$gpgOut" | egrep "^(sec|ssb):" | cut -d: -f 12 | grep -q a ; then
	echo "An authentication subkey already exists for key '$keyID'."
	read -p "Are you sure you would like to generate another one? (y/N) " OK; OK=${OK:N}
	if [ "${OK/y/Y}" != 'Y' ] ; then
	    failure "aborting."
	fi
    fi

    # set subkey defaults
    # prompt about key expiration if not specified
    if [ -z "$keyExpire" ] ; then
	cat <<EOF
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
EOF
	while [ -z "$keyExpire" ] ; do
	    read -p "Key is valid for? (0) " keyExpire
	    if ! test_gpg_expire ${keyExpire:=0} ; then
		echo "invalid value"
		unset keyExpire
	    fi
	done
    elif ! test_gpg_expire "$keyExpire" ; then
	failure "invalid key expiration value '$keyExpire'."
    fi

    # generate the list of commands that will be passed to edit-key
    editCommands=$(cat <<EOF
addkey
7
S
E
A
Q
$keyLength
$keyExpire
save
EOF
)

    log "generating subkey..."
    fifoDir=$(mktemp -d)
    (umask 077 && mkfifo "$fifoDir/pass")
    echo "$editCommands" | gpg --passphrase-fd 3 3< "$fifoDir/pass" --expert --command-fd 0 --edit-key "$keyID" &
    
    if [ "$DISPLAY" ] && which ssh-askpass >/dev/null; then
	ssh-askpass "Please enter your passphrase for $keyID: " > "$fifoDir/pass"
    else
	read -s -p "Please enter your passphrase for $keyID: " PASS
	echo "$PASS" > "$fifoDir/pass"
    fi
    rm -rf "$fifoDir"
    wait
    log "done."
}

########################################################################
# MAIN
########################################################################

# unset variables that should be defined only in config file
unset KEYSERVER
unset CHECK_KEYSERVER
unset KNOWN_HOSTS
unset HASH_KNOWN_HOSTS
unset AUTHORIZED_KEYS

# load global config
[ -r "${ETC}/monkeysphere.conf" ] && . "${ETC}/monkeysphere.conf"

# set monkeysphere home directory
MONKEYSPHERE_HOME=${MONKEYSPHERE_HOME:="${HOME}/.config/monkeysphere"}
mkdir -p -m 0700 "$MONKEYSPHERE_HOME"

# load local config
[ -e ${MONKEYSPHERE_CONFIG:="${MONKEYSPHERE_HOME}/monkeysphere.conf"} ] && . "$MONKEYSPHERE_CONFIG"

# set empty config variables with ones from the environment, or from
# config file, or with defaults
GNUPGHOME=${MONKEYSPHERE_GNUPGHOME:=${GNUPGHOME:="${HOME}/.gnupg"}}
KEYSERVER=${MONKEYSPHERE_KEYSERVER:="$KEYSERVER"}
# if keyserver not specified in env or monkeysphere.conf,
# look in gpg.conf
if [ -z "$KEYSERVER" ] ; then
    if [ -f "${GNUPGHOME}/gpg.conf" ] ; then
	KEYSERVER=$(grep -e "^[[:space:]]*keyserver " "${GNUPGHOME}/gpg.conf" | tail -1 | awk '{ print $2 }')
    fi
fi
# if it's still not specified, use the default
KEYSERVER=${KEYSERVER:="subkeys.pgp.net"}
CHECK_KEYSERVER=${MONKEYSPHERE_CHECK_KEYSERVER:=${CHECK_KEYSERVER:="true"}}
KNOWN_HOSTS=${MONKEYSPHERE_KNOWN_HOSTS:=${KNOWN_HOSTS:="${HOME}/.ssh/known_hosts"}}
HASH_KNOWN_HOSTS=${MONKEYSPHERE_HASH_KNOWN_HOSTS:=${HASH_KNOWN_HOSTS:="true"}}
AUTHORIZED_KEYS=${MONKEYSPHERE_AUTHORIZED_KEYS:=${AUTHORIZED_KEYS:="${HOME}/.ssh/authorized_keys"}}

# other variables not in config file
AUTHORIZED_USER_IDS=${MONKEYSPHERE_AUTHORIZED_USER_IDS:="${MONKEYSPHERE_HOME}/authorized_user_ids"}
REQUIRED_HOST_KEY_CAPABILITY=${MONKEYSPHERE_REQUIRED_HOST_KEY_CAPABILITY:="a"}
REQUIRED_USER_KEY_CAPABILITY=${MONKEYSPHERE_REQUIRED_USER_KEY_CAPABILITY:="a"}

# export GNUPGHOME and make sure gpg home exists with proper
# permissions
export GNUPGHOME
mkdir -p -m 0700 "$GNUPGHOME"

# get subcommand
COMMAND="$1"
[ "$COMMAND" ] || failure "Type '$PGRM help' for usage."
shift

case $COMMAND in
    'update-known_hosts'|'update-known-hosts'|'k')
	MODE='known_hosts'

	# check permissions on the known_hosts file path
	if ! check_key_file_permissions "$USER" "$KNOWN_HOSTS" ; then
	    failure "Improper permissions on known_hosts file path."
	fi

        # if hosts are specified on the command line, process just
        # those hosts
	if [ "$1" ] ; then
	    update_known_hosts "$@"
	    RETURN="$?"

        # otherwise, if no hosts are specified, process every host
        # in the user's known_hosts file
	else
	    # exit if the known_hosts file does not exist
	    if [ ! -e "$KNOWN_HOSTS" ] ; then
		log "known_hosts file '$KNOWN_HOSTS' does not exist."
		exit
	    fi

	    process_known_hosts
	    RETURN="$?"
	fi
	;;

    'update-authorized_keys'|'update-authorized-keys'|'a')
	MODE='authorized_keys'

	# check permissions on the authorized_user_ids file path
	if ! check_key_file_permissions "$USER" "$AUTHORIZED_USER_IDS" ; then
	    failure "Improper permissions on authorized_user_ids file path."
	fi

	# check permissions on the authorized_keys file path
	if ! check_key_file_permissions "$USER" "$AUTHORIZED_KEYS" ; then
	    failure "Improper permissions on authorized_keys file path."
	fi

        # exit if the authorized_user_ids file is empty
	if [ ! -e "$AUTHORIZED_USER_IDS" ] ; then
	    log "authorized_user_ids file '$AUTHORIZED_USER_IDS' does not exist."
	    exit
	fi

	# process authorized_user_ids file
	process_authorized_user_ids "$AUTHORIZED_USER_IDS"
	RETURN="$?"
	;;

    'gen-subkey'|'g')
	gen_subkey "$@"
	;;

    'help'|'h'|'?')
        usage
        ;;

    *)
        failure "Unknown command: '$COMMAND'
Type '$PGRM help' for usage."
        ;;
esac

exit "$RETURN"
